<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>PythonMyLife</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="PythonMyLife">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="PythonMyLife">
<meta property="og:locale">
<meta property="article:author" content="hzt">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="PythonMyLife" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PythonMyLife</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/03/hello-world/" class="article-date">
  <time datetime="2020-12-03T09:15:00.108Z" itemprop="datePublished">2020-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/03/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/12/03/hello-world/" data-id="cki8n7m7g0006iil4ajntg2vj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/03/Java%E6%B5%81/" class="article-date">
  <time datetime="2020-12-03T05:58:02.000Z" itemprop="datePublished">2020-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/03/Java%E6%B5%81/">Java流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文基于Java SE 8的流库</p>
<h2 id="更简约的迭代"><a href="#更简约的迭代" class="headerlink" title="更简约的迭代"></a>更简约的迭代</h2><p>如果我们需要遍历一个集合的元素来选出我们想要的部分，我们通常会选择迭代的方式来解决问题，例如我们想要从数组中找到大于1000的元素的个数，我们可以这样编写我们的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer num : nums) &#123;</span><br><span class="line">    count += num &gt; <span class="number">1000</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用流来操作，我们的代码则会是下面这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = nums.stream().filter(num -&gt; num &gt; <span class="number">1000</span>).count();</span><br></pre></td></tr></table></figure>

<p>也可以将<code>stream</code>修改为<code>parallelStream</code>来并行地执行过滤和计数，像是这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = nums.parallelStream().filter(num -&gt; num &gt; <span class="number">1000</span>).count();</span><br></pre></td></tr></table></figure>

<p>在流操作中，我们首先创建了一个流，之后使用<code>filter</code>将初始流转换成了其他的流，最后使用<code>count</code>执行了之前的惰性操作，产生出了我们想要的结果。</p>
<p>所以我们可以总结出操作流的典型流程：</p>
<ul>
<li>创建一个初始流。</li>
<li>指定将初始流转换成其他流的中间操作，中间操作可能包含多个步骤。</li>
<li>应用终止操作，从而产生结果。这个操作会强制执行之前的惰性操作。</li>
</ul>
<p>除此之外，流还有几点性质：</p>
<ul>
<li>流并不会对元素进行存储，这些元素可能存储在底层的集合中，或者是按需生成的。</li>
<li>流的操作不会修改数据源，比如<code>filter</code>过滤之后只是生成了一个新的流，而不是将数据源中不符合条件的元素给过滤掉了。</li>
<li>流的操作是惰性执行的，只有当需要流的结果时操作才会执行。</li>
</ul>
<h2 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h2><p>首先，我们来看一看如何创建流</p>
<ul>
<li><p>对于<code>Collection</code>的实现类可以使用<code>Collection</code>的<code>stream</code>方法将任何集合转换成一个流。</p>
</li>
<li><p>对于数组来说，可以使用静态的<code>Stream.of()</code>方法，或者可以使用<code>Arrays.stream(array, from, to)</code>来使用数组中位于<code>from</code>和<code>to</code>之间的元素来创建一个流。</p>
</li>
<li><p>创建空流可以使用静态的<code>Stream.empty()</code>方法。</p>
</li>
<li><p>创建无限流有两种方法</p>
<ul>
<li><p>可以使用<code>generate</code>方法来创建无限流，该方法会接受一个不包含任何引元的函数，当需要一个流类型的值的时候，就会执行该函数以产生一个这样的值，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; nums = Stream.generate(() -&gt; <span class="number">1</span>);</span><br><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random);</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以使用<code>iterate</code>方法来创建，该方法会接受一个“种子”和一个函数，每次调用会将函数应用到之前的结果上，例如我们想产生一个0 1 2 3这样的流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; nums = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="流的转换"><a href="#流的转换" class="headerlink" title="流的转换"></a>流的转换</h2><h3 id="filter、map和flatMap方法"><a href="#filter、map和flatMap方法" class="headerlink" title="filter、map和flatMap方法"></a>filter、map和flatMap方法</h3><ul>
<li><p><code>filter</code>会产生一个新的只包含满足给出条件的元素的流，<code>filter</code>的引元为<code>T</code>到<code>boolean</code>的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; count = nums.stream().filter(num -&gt; num &gt; <span class="number">1000</span>).count();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>map</code>方法会按照某种方式来转换流中的值，例如我们可以这样将所有单词转换为小写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; lowerCaseWords = words.stream().map(String::toLowerCase);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flatMap</code>方法会对流中的每个元素执行方法，并将方法生成的流加入得到的流中，例如我们可以将单词的流按照下面的转换转换成字母流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法将String类型的s转换为s的每个字母组成的流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">letters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    list&lt;String&gt; letters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        letters.add(s.subString(i, i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.stream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将单词流转换成一个由每个单词的字母组成的字母流</span></span><br><span class="line">Stream&lt;String&gt; letterStream = words.stream().flatMap(w -&gt; letters(w));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="抽取子流和连接流"><a href="#抽取子流和连接流" class="headerlink" title="抽取子流和连接流"></a>抽取子流和连接流</h3><ul>
<li><p>可以使用<code>limit</code>方法和<code>skip</code>方法来抽取流中我们需要的元素。</p>
<ul>
<li><p><code>limit(n)</code>会返回一个新的流，在n个元素之后结束。例如可以使用以下的方法来得到100个随机数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Double&gt; randoms = Stream.generate(Math::random).limit(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>skip(n)</code>会舍弃流中的前n个元素，这个方法可以用于跳过无用的元素。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(contents.split(<span class="string">&quot;\\PL+&quot;</span>)).skip(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可以使用<code>concat</code>方法来连接流，不过第一个流不应该是无限的，否则第二个流永远不会被处理。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; combined = Stream.concat(Stream.of(<span class="string">&quot;hello&quot;</span>), Stream.of(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="其他的流转换"><a href="#其他的流转换" class="headerlink" title="其他的流转换"></a>其他的流转换</h3><ul>
<li><p><code>distinct</code>会剔除重复的元素，例如以下流在操作后就只剩下一个”a”了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; distinct = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>).distinct();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sorted</code>可以对流中的元素进行排序，可以对<code>Comparable</code>元素进行排序也可以接受一个<code>Comparator</code>进行排序，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; smallFirst = nums.stream().sorted();</span><br><span class="line">Stream&lt;Integer&gt; bigFirst = nums.stream().sorted((a, b) -&gt; a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>peek</code>会产生一个与原流相同的流，不过在每次获取元素时都会调用一个函数，例如可以这样调试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = nums.stream().filter(num -&gt; num &gt; <span class="number">1000</span>).peek(num -&gt; System.out.println(<span class="string">&quot;Fetching: &quot;</span> + num)).count();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="流的约简"><a href="#流的约简" class="headerlink" title="流的约简"></a>流的约简</h2><p>在创建流以及对流进行转换之后，我们需要从流中得到答案，这种操作称为流的约简。</p>
<table>
<thead>
<tr>
<th>约简方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>long count()</code></td>
<td>返回当前流中的数量</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; max(Comparator &lt;? super T&gt; comparator)</code></td>
<td>返回当前流中的最大值</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; min(Comparator &lt;? super T&gt; comparator)</code></td>
<td>返回当前流中的最小值</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; findFirst()</code></td>
<td>返回当前流中的第一个元素</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt; findAny()</code></td>
<td>返回当前流中的任意一个元素</td>
</tr>
<tr>
<td><code>bollean anyMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td>当前流中任意一个元素满足断言时返回<code>true</code></td>
</tr>
<tr>
<td><code>bollean allMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td>当前流中全部元素都满足断言时返回<code>true</code></td>
</tr>
<tr>
<td><code>bollean noneMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td>当前流中没有一个元素满足断言时返回<code>true</code></td>
</tr>
</tbody></table>
<h2 id="流的收集"><a href="#流的收集" class="headerlink" title="流的收集"></a>流的收集</h2><p>有时我们在处理流中元素的时候想要查看元素或者做一些处理，这时我们就需要使用一些流的收集方法。</p>
<ul>
<li><p><code>iterator</code>方法可以返回一个迭代处理流中元素的迭代器，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = nums.stream().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forEach</code>方法可以将函数应用到流中的每个元素上，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>不过如果是并行流，那么<code>forEach</code>方法会以任意顺序遍历各个元素，如果想要按流顺序来处理则可以使用<code>forEachOrdered</code>方法，不过这种方法会带来性能损失。</p>
</li>
</ul>
<p>不过更为常见的应用场景是将结果收集到数据结构中，此时可以调用<code>toArray()</code>获得由流的元素组成的数组，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] result = stream.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>或者，更简便地，我们可以使用<code>collect</code>方法，它会接受一个<code>Collection</code>接口的实例，<code>Collectors</code>类提供了大量用于生成公共收集器的工厂方法，可以将流中的元素收集到列表或者集合中，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">// 收集到列表中</span></span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 收集到集合中</span></span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br><span class="line"><span class="comment">// 控制获得集合的种类</span></span><br><span class="line">Set&lt;String&gt; treeSet = stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">// 连接操作</span></span><br><span class="line">String result = stream.collect(Collectors.joining());</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/12/03/Java%E6%B5%81/" data-id="cki8n7m720001iil41ecz2hhf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-12-03T02:58:02.000Z" itemprop="datePublished">2020-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><table>
    <tr>
        <th>分类</th>
        <th>具体分类</th>
        <th>被锁对象</th>  
        <th>伪代码</th>
    </tr >
    <tr >
        <td rowspan="2">方法</td>
        <td>实例方法</td>
        <td>类的实例对象</td>
        <td>
        // 实例方法，锁住的是类的实例对象<br>
        public synchronized void method() {}
        </td>
    </tr>
    <tr >
        <td>静态方法</td>
        <td>类对象</td>
        <td>
        // 静态方法，锁住的是类对象<br>
        public static synchronized void method() {}
        </td>
    </tr>
    <tr >
        <td rowspan="3">代码块</td>
        <td>实例对象</td>
        <td>类的实例对象</td>
        <td>
        // 同步代码块，锁住的是该类的实例对象<br>
        synchronized (this) {}
        </td>
    </tr>
    <tr >
        <td>class对象</td>
        <td>类对象</td>
        <td>
        // 同步代码块，锁住的是类对象<br>
        synchronized (ApplicationFactory.this) {}
        </td>
    </tr>
    <tr >
        <td>实例对象</td>
        <td>实例对象Object</td>
        <td>
        // 同步代码块，锁住的是配置的实例对象<br>
        Object o = new Object();
        synchronized (o) {}
        </td>
    </tr>
</table>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对方法、同步块的同步的。</p>
<ul>
<li>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</li>
<li>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</li>
<li>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</li>
</ul>
<p>流程图：</p>
<p><img src="./synchronized%E6%B5%81%E7%A8%8B.jpg" alt="synchronized流程"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="CAS和轻量锁"><a href="#CAS和轻量锁" class="headerlink" title="CAS和轻量锁"></a>CAS和轻量锁</h5><p>使用锁时，线程获取锁是一种<strong>悲观锁策略</strong>，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作（又称为无锁操作）是一种<strong>乐观锁策略</strong>，它假设所有线程访问共享资源的时候不会出现冲突，因此线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用**CAS(compare and swap)**又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。</p>
<h6 id="CAS的操作过程"><a href="#CAS的操作过程" class="headerlink" title="CAS的操作过程"></a>CAS的操作过程</h6><p>CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：<strong>V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值</strong>。当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试。</p>
<h6 id="使用CAS的轻量锁"><a href="#使用CAS的轻量锁" class="headerlink" title="使用CAS的轻量锁"></a>使用CAS的轻量锁</h6><ul>
<li>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</li>
<li>如果更新<strong>成功</strong>，当前线程就获得了锁。</li>
<li>如果更新<strong>失败</strong> <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</li>
<li>轻量锁的解锁过程也是利用 <code>CAS</code> 来实现的，会尝试锁记录替换回锁对象的 <code>Mark Word</code> 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为<code>重量锁</code>)</li>
</ul>
<h6 id="最初的方式和CAS的比较"><a href="#最初的方式和CAS的比较" class="headerlink" title="最初的方式和CAS的比较"></a>最初的方式和CAS的比较</h6><p>Synchronized(未优化前)最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而CAS并不是武断的间线程挂起，当CAS操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 <code>CAS</code> 的开销，甚至比重量锁更慢。</p>
<h6 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h6><ul>
<li><p><strong>ABA问题</strong><br> 因为CAS会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以通过添加一个版本号来解决。</p>
</li>
<li><p><strong>自旋时间过长</strong></p>
<p>使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong></p>
<p>当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。</p>
</li>
</ul>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><h6 id="偏向锁的操作过程"><a href="#偏向锁的操作过程" class="headerlink" title="偏向锁的操作过程"></a>偏向锁的操作过程</h6><ul>
<li>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</li>
</ul>
<h5 id="各种锁的比较"><a href="#各种锁的比较" class="headerlink" title="各种锁的比较"></a>各种锁的比较</h5><p><img src="%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E6%AF%94%E8%BE%83.webp" alt="各种锁的比较"></p>
<h3 id="常用的锁🔒"><a href="#常用的锁🔒" class="headerlink" title="常用的锁🔒"></a>常用的锁🔒</h3><ul>
<li><p>synchronized关键字的缺陷</p>
<ul>
<li>如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待</li>
<li>当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</li>
<li>通过synchronized无法知道线程有没有成功获取到锁。</li>
</ul>
</li>
<li><p>Lock</p>
<ul>
<li>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。<strong>虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</strong></li>
<li>注意点：<ul>
<li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问。</li>
<li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock()</td>
<td>获取锁</td>
</tr>
<tr>
<td>lockInterruptibly()</td>
<td>获取锁的过程能够响应中断</td>
</tr>
<tr>
<td>tryLock()</td>
<td>非阻塞式响应中断能立即返回，获取锁放回true反之返回fasle</td>
</tr>
<tr>
<td>tryLock(long time, TimeUnit unit)</td>
<td>超时获取锁，在超时内或者未中断的情况下能够获取锁</td>
</tr>
<tr>
<td>unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td>newCondition()</td>
<td>获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/12/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="cki8n7m6x0000iil45udk6l6h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/java/" style="font-size: 10px;">java</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/03/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/12/03/Java%E6%B5%81/">Java流</a>
          </li>
        
          <li>
            <a href="/2020/12/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 hzt<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>